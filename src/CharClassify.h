// Scintilla source code edit control
/** @file CharClassify.h
 ** Character classifications used by Document and RESearch.
 **/
// Copyright 2006-2009 by Neil Hodgson <neilh@scintilla.org>
// The License.txt file describes the conditions under which this software may be distributed.
#pragma once

namespace Scintilla::Internal {

bool DBCSIsLeadByte(int codePage, unsigned char uch) noexcept;

constexpr bool IsDBCSCodePage(int codePage) noexcept {
	return codePage == 932
		|| codePage == 936
		|| codePage == 949
		|| codePage == 950
		|| codePage == 1361;
}

constexpr bool IsDBCSValidSingleByte(int codePage, int ch) noexcept {
	switch (codePage) {
	case 932:
		return ch == 0x80
			|| (ch >= 0xA0 && ch <= 0xDF)
			|| (ch >= 0xFD);

	default:
		return false;
	}
}

//grapheme type++Autogenerated -- start of section automatically generated
enum class GraphemeBreakProperty {
	Other = 0,
	Control = 1,
	Extend = 2,
	RegionalIndicator = 3,
	Prepend = 4,
	HangulL = 5,
	HangulV = 6,
	HangulT = 7,
	HangulLV = 8,
	HangulLVT = 9,
	ExtendedPictographic = 10,
	ZeroWidthJoiner = 11,
	ConjunctLinker = 12,
	LinkingConsonant = 13,
	ExtendConjunctLinker = 14,
	ForwardSentinel = Prepend,
	BackwardSentinel = Extend,
};

constexpr int maxUnicodeGraphemeBreakCharacter = 0xe1000;
constexpr int longestUnicodeCharacterSequenceCount = 10;
constexpr int longestUnicodeCharacterSequenceBytes = 35;

constexpr uint16_t graphemeClusterBoundary[] = {
0b00110111'11111011, // Other
0b11111111'11111111, // Control
0b00110111'11111011, // Extend
0b00110111'11110011, // RegionalIndicator
0b00000000'00000010, // Prepend
0b00110100'10011011, // HangulL
0b00110111'00111011, // HangulV
0b00110111'01111011, // HangulT
0b00110111'00111011, // HangulLV
0b00110111'01111011, // HangulLVT
0b00110111'11111011, // ExtendedPictographic
0b00010011'11111011, // ZeroWidthJoiner
0b00010111'11111011, // ConjunctLinker
0b00100111'11111011, // LinkingConsonant
0b00010111'11111011, // ExtendConjunctLinker
};

constexpr bool IsGraphemeClusterBoundary(GraphemeBreakProperty prev, GraphemeBreakProperty current) noexcept {
	return (graphemeClusterBoundary[static_cast<int>(prev)] >> (static_cast<int>(current))) & true;
}
//grapheme type--Autogenerated -- end of section automatically generated

class CharClassify {
public:
	CharClassify() noexcept;

	void SetDefaultCharClasses(bool includeWordClass) noexcept;
	void SetCharClasses(const unsigned char *chars, CharacterClass newCharClass) noexcept;
	void SetCharClassesEx(const unsigned char *chars, size_t length) noexcept;
	int GetCharsOfClass(CharacterClass characterClass, unsigned char *buffer) const noexcept;
	CharacterClass GetClass(unsigned char ch) const noexcept {
		return static_cast<CharacterClass>(charClass[ch]);
	}
	bool IsWord(unsigned char ch) const noexcept {
		return GetClass(ch) == CharacterClass::word;
	}

	static void InitUnicodeData() noexcept;

//++Autogenerated -- start of section automatically generated
// Created with Python 3.14.0a5, Unicode 16.0.0
	static CharacterClass ClassifyCharacter(uint32_t ch) noexcept {
		if (ch < sizeof(classifyMap)) {
			return static_cast<CharacterClass>(classifyMap[ch]);
		}
		if (ch >= 0xe01f0) {
			return CharacterClass::space; // Cn
		}

		ch -= sizeof(classifyMap);
		ch = (CharClassifyTable[ch >> 11] << 9) | (ch & 2047);
		ch = (CharClassifyTable[(ch >> 6) + 417] << 6) | (ch & 63);
		ch = (CharClassifyTable[(ch >> 3) + 1481] << 3) | (ch & 7);
		return static_cast<CharacterClass>(CharClassifyTable[ch + 3089]);
	}
//--Autogenerated -- end of section automatically generated

//grapheme function++Autogenerated -- start of section automatically generated
	static GraphemeBreakProperty GetGraphemeBreakProperty(uint32_t ch) noexcept {
		if (ch < sizeof(graphemeMap)) {
			return static_cast<GraphemeBreakProperty>(graphemeMap[ch]);
		}
		if (ch >= maxUnicodeGraphemeBreakCharacter) {
			return GraphemeBreakProperty::Other;
		}

		ch -= sizeof(graphemeMap);
		ch = (GraphemeBreakTable[ch >> 12] << 8) | (ch & 4095);
		ch = (GraphemeBreakTable[(ch >> 7) + 221] << 6) | (ch & 127);
		ch = (GraphemeBreakTable[(ch >> 3) + 733] << 3) | (ch & 7);
		return static_cast<GraphemeBreakProperty>(GraphemeBreakTable[ch + 2237]);
	}
//grapheme function--Autogenerated -- end of section automatically generated

private:
	static constexpr uint32_t maxUnicode = 0x10ffff;
	static const uint8_t CharClassifyTable[];
	static const uint8_t GraphemeBreakTable[];
	static uint8_t classifyMap[0xffff + 1];
	static uint8_t graphemeMap[0x4000];

	static constexpr int maxChar = 256;
	uint8_t charClass[maxChar];
};

class DBCSCharClassify {
public:
	explicit DBCSCharClassify(int codePage_) noexcept;

	bool IsLeadByte(unsigned char ch) const noexcept {
		return leadByte[ch] & true;
	}
	bool IsTrailByte(unsigned char ch) const noexcept {
		return leadByte[ch] & 2;
	}

	CharacterClass ClassifyCharacter(uint32_t ch) const noexcept {
		if (ch < sizeof(classifyMap)) {
			return static_cast<CharacterClass>(classifyMap[ch]);
		}
		// Cn
		return CharacterClass::space;
	}

private:
	uint8_t leadByte[256];
	unsigned char classifyMap[0xffff + 1];
};

}
